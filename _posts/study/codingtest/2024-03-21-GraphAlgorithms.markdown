---
layout: post
title:  Graph Algorithms (서로소집합, 크루스칼 알고리즘, 위상정렬)
date:   2024-03-21 19:15:16 +0900
categories: study
tags: codingtest graph
---

### 서로소 집합 알고리즘 Disjoint Set
서로소 집합(Disjoint Set)은 서로 공유하는 요소가 아예 없는 집합이다. 

서로소 집합 알고리즘은 "union"과 "find" 라는 두 종류의 작업을 반복함으로써 임의의 무향 그래프에서 서로소 집합을 빠르게 찾아줄 수 있는 알고리즘이다. 

서로소집합이 유용한 이유는 그래프가 주어졌을 때, "그래프의 부분집합"을 가장 빠르게 찾을 수 있기 때문이다. 

그래프의 부분집합이 어떤 의미인지 알기 위해 다음 그림을 보자. 

![two_models]({{"/assets/images/2024-03-21-GraphAlgorithm_1.PNG/" |  relative_url}})

9개의 노드가 있고 노드의 간선 정보들을 저렇게 리스트로 받았다고 가정하자. 연결 상태를 보면 이 그래프는 총 3개의 부분 그래프로 나눌 수 있다.

![two_models]({{"/assets/images/2024-03-21-GraphAlgorithm_2.PNG/" |  relative_url}})

서로 간에 노드를 공유하지 않는 총 3개의 부분 그래프가 존재함을 알 수 있다. 부분 그래프의 수를 알아야 할 필요는 여러가지가 있겠지만, 대표적으로 해당 그래프에서 전체 순회가 가능한지 여부를 빠르게 파악할 수 있다. 주어진 그래프에서 서로소 집합이 2개 이상인 순간부터 주어진 간선만으로는 절대로 모든 노드를 방문할 수 없기 때문이다. 

물론 DFS나 BFS로 직접 모든 노드들을 방문하면서 확인하는 방법도 있겠지만, 서로소 집합 알고리즘은 훨씬 간단한 코드로 이를 파악할 수 있다.

(방향 그래프일 경우 DFS로 확인해야 한다)

이를 위해 서로소집합은 각 서브그래프를 일종의 트리처럼 표현하는 전략을 취한다. 모든 노드의 번호가 고유한 숫자라면, 서로 간에 상하관계가 존재한다. 즉 1번 -> 2번이 이어져 있을 때, 비록 주어진 간선의 방향은 다르다만, 어쨌든 간선으로 인해 연결된 노드들은 무조건 더 큰 노드가 더 작은 노드를 가리키고 있다고 간주한다. 즉 이 경우엔 2번이 1번을 가리키고 있다고 간주하는 거다. 
똑같이 4번도 1번, 그리고 5번은 2번을 가리키고 있다고 가정하면, [1, 2, 4, 5]의 4개 노드로 이루어진 빨간색 서브그래프는 1번 노드를 root로 하는 트리로 보겠다는 것이다.

즉 서로소 집합의 기준은 `최상단 노드를 서로 공유하고 있는 노드 집합`이 되는 것이다. 

어떤 임의의 노드가 주어졌을 때 해당 노드가 가리키는 최상단 부모 노드를 반환하는 find 함수, 
그리고 두 노드가 같은 서로소 집합에 포함시키는 union 함수, 
이렇게 2개를 가지고 알고리즘을 진행할 수 있다.

```python
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x]) # recursively find the uppermost node of node x 
    return parent[x]

def union(parent, a, b): 
    # if the current uppermost nodes are different for node a and b, make one to point to the other
    a = find(parent, a)
    b = find(parent, b)
    if a < b: 
        parent[b] = a 
    else:
        parent[a] = b 
```

```python
# 시작하기 전에 노드 개수 N만큼 parent array를 만들고 실행
parent = [i for i in range(N)] # 시작할 때는 모든 노드는 자기 자신의 번호를 부모로 갖고 있음

for i in range(E): # 각 노드별로 
    a, b = map(int, sys.stdin.readline().split()) # 간선 별로 union 연산 실행
    union(parent, a, b)
```

결과를 출력하면 예상대로 나온다. 유의할 점은 parent는 각 노드가 가리키는 최상단 노드를 직접 저장하는게 아니기 때문에 실제로 특정 노드가 어느 그룹에 속하는지를 보려면 find()를 더 써서 recursive하게 직접 찾아야 한다.
```

![two_models]({{"/assets/images/2024-03-21-GraphAlgorithm_3.PNG/" |  relative_url}})



### 크루스칼 알고리즘
크루스칼 알고리즘은 그리디 알고리즘으로 분류된다. 하나의 그래프가 있을 때, 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 
`신장 트리`라고 부른다. 그 중에서도 최소한의 간선비용합을 가진 신장 트리를 `최소신장트리`라고 한다.

모든 간선에 대해 정렬을 수행한 후, 가장 비용이 낮은 간선부터 차례대로 집합에 포함시키면 된다. 매번 간선을 추가할 때마다 해당 간선을 추가함으로 cycle이 발생하는지 여부를 확인한다.

이때 위에서 소개한 union과 find 함수를 써서 간단하게 집합추가 및 cycle 판정을 할 수 있다. 
cycle은 어느 경우 발생하는가? 

a, b 간 간선을 확인할 때 만약 find(a) == find(b)일 경우를 생각해보자. 최초에 a,b의 부모 노드는 각각의 노드번호와 맞게 실행했으므로, 두 노드가 처음 방문하는 경우일 때는 위 부등식이 성립할 가능성 자체가 아예 없다. 즉 a나 b 최소 둘 중 하나는 이미 서브그래프에 포함된 상태여야만 해당 조건이 발생할 확률이 있다.

a가 서브그래프에 포함되어 있는데, 새롭게 들어온 b가 a와 같은 최상단노드를 가리키고 있는 상태 (최상단 노드를 c라고 하자)라면 b는 이미 서브그래프에 포함된 경우이다. 그리고 서로소 집합은 무향그래프이므로, 

a--c 
b--c
a--b 

바로 cycle이 생긴다.


### 위상 정렬 Topology Sort
위상정렬 Topological Sorting은 `방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것`이다.

1. 진입차수가 0인 노드를 큐에 넣는다.
2. 큐가 빌 때까지 다음의 과정을 반복한다.  
    2.1  큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.  
    2.2  새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

진입차수(indegree)는 특정한 노드로 "들어오는" 간선 개수를 말한다.  
이때 모든 노드를 방문하지 못했는데 큐가 비어버린다면 사이클이 존재한다고 판단할 수 있다. 

왜냐하면 DAG(directed Acyclic Graph)에서는 진입차수가 0인 노드가 무조건 1개는 있어야 한다. 
queue가 빈다는 것은 진입차수가 0인 노드가 현재 하나도 없다는 뜻이고, 진입차수가 0인 노드가 없다는 것은 현재 cycle이 있다는 것이다.

예시 그림을 첨부한다.


![two_models]({{"/assets/images/2024-03-21-GraphAlgorithm_4.PNG/" |  relative_url}})

모든 노드의 진입차수가 1 이상인 것은 cycle이 있음을 의미한다.